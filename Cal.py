m = []                                                        # 계산을 수행하는 리스트
comp = []                                                     # 수식 구성요소를 분리하여 추가할 리스트


#----------------수식 입력 및 구성 요소 분류, 오류 파악---------------------------------------------------------------------------------------------------------------------
#조금 더 엄밀한 분류 방법이 필요해 보이지만 계산기 작동에는 문제 없음

inp = input("수식을 입력: ")
ran = range(len(inp))
s = ['(', '+', '-', '*', '/', ')']
ar = ['+','-','*','/']

for i in ran:
    chr = inp[i]
    
    if chr.isalpha():                                         # 숫자나 연산자 외 문자 입력 시 오류
        print('올바른 수식을 입력하세오.')
        break
        
    elif comp == []:                                          # 첫 번째 숫자나 연산자는 무조건 리스트에 추가
        comp.append(chr)
    

    elif chr in ar and comp[-1] in ar:                        # 연산자 연속으로 입력 시 오류
        print('수식 오류: 연산자를 연속으로 입력')
        break
        
    elif comp[-1].isdigit() and chr =='(':                    # 숫자와 괄호 사이 연산자 필수 입력
        print('수식 오류: 숫자와 괄호 사이 연산자 미입력')
        break
    
    elif chr.isdigit() and comp[-1] ==')':
        print('수식 오류: 숫자와 괄호 사이 연산자 미입력')
        break    
    
    elif chr in s:                                            # 괄호나 연산자는 리스트에 분리하여 추가
        comp.append(chr) 
        
    elif comp[-1] in s:                                       # 앞 자리가 괄호나 연산자일 시 리스트에 분리하여 추가
        comp.append(chr)  
    
    else:                                                     # 앞 자리가 괄호나 연산자가 아닐 경우, 숫자일 것이므로 분리하지 않고 합쳐서 추가 ex) '1','2','3'이 아닌 '123'으로
        comp[-1] = comp[-1]+chr

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------사칙연산 수행 함수--------------------------------------------------------------------------------------------------------------------------------
#나눗셈과 뺄셈은 곱셈과 덧셈으로 바꿔준 후 곰셈부터 앞에서부터 계산

def arith(x):
    while '/' in x:
        div = x.index('/')
        divex = 1 / float(x[div+1])
        del x[div:div+2]
        x.insert(div,'*')
        x.insert(div+1, str(divex))
        
    while '-' in x:
        sub = x.index('-')
        minex = -float(x[sub+1])
        del x[sub:sub+2]
        x.insert(sub,'+')
        x.insert(sub+1, str(minex))
        
    while '*' in x:
        mul = x.index('*')
        mulre = float(x[mul-1]) * float(x[mul+1])
        del x[mul-1:mul+2]
        x.insert(mul-1, str(mulre))
        
    while '+' in x:
        add = x.index('+')
        addre = float(x[add-1]) + float(x[add+1])
        del x[add-1:add+2]
        x.insert(add-1, str(addre))
        
    return float(x[0])

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------괄호 계산----------------------------------------------------------------------------------------------------------------------------------------

def n_par(x):                                             # 첫 번째 ')' 가 나올 때, ')'보다 앞에 위치하면서 가장 가까운 '('의 위치를 함께 기록.
    parp = 0
    parm = 0                                        
    lenx = len(x)
    for i in range(lenx):
        if x[i] == '(':
            parp = i
        
        elif x[i] == ')':
            parm = i
            break
    return parp, parm


def par(x):                                               # 가장 우선적으로 계산할 괄호 내 사칙연산 수식을 계산하고 그 값을 리스트 내 해당 위치에 반환, 괄호 제거
    par = x[n_par(x)[0]+1:n_par(x)[1]]
    paa = arith(par)
    x.insert(n_par(x)[1]+1, float(paa))
    del x[n_par(x)[0]:n_par(x)[1]+1]
    return x

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------실제 계산 수행-------------------------------------------------------------------------------------------------------------------------------------

m.append(comp)

if '(' and ')' not in comp:                               # 괄호가 없으면 바로 사칙연산 수행
    print(f'정답: {arith(m[-1]):.5f}')

else:
    nop = comp.count('(')                                 # 괄호가 있으면 리스트 m 에 구성 요소를 담은 리스트 append
    while nop > 0:                                        # 이후 괄호의 개수 만큼 괄호 계산 반복 수행, 수행 결과는 리스트 m에 append
        m.append(par(m[-1]))                                
        nop += -1
       
    if nop == 0:                                          # 리스트m에 마지막으로 추가된(괄호가 다 벗겨진) 수식에 사칙연산 수행  
        print(f'정답: {arith(m[-1]):.5f}')
    
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------    

        

