m = []                                                        # 계산 수행 모집합
comp = []                                                     # 수식 구성요소 분리


#----------------수식 입력 및 구성 요소 분리----------------------------------------------------------------------------------------------------------------------------

inp = input("수식을 입력: ")
ran = range(len(inp))
s = ['(', '+', '-', '*', '/', ')']
ar = ['+','-','*','/']

for i in ran:
    chr = inp[i]
    
    if chr.isalpha():                                         # 문자 입력시 오류
        print('수식 오류: 올바른 수식을 입력')
        break
    
    elif comp == []:                                          # 첫 번째 문자열은 무조건 추가
        comp.append(chr)
    

    elif chr in ar and comp[-1] in ar:                        # 연산자가 연속으로 나오면 오류 출력
        print('수식 오류: 연산자를 연속으로 입력')
        break
        
    elif comp[-1].isdigit() and chr =='(':                    # 숫자와 괄호 사이 연산자 입력
        print('수식 오류: 숫자와 괄호 사이 연산자를 입력')
        break
    
    elif chr.isdigit() and comp[-1] ==')':
        print('수식 오류: 숫자와 괄호 사이 연산자를 입력')
        break    
    
    elif chr in s:                                            # 연산 기호 추가
        comp.append(chr) 
        
    elif comp[-1] in s:                                       # 앞 자리가 연산 기호일 시 추가
        comp.append(chr)  
    
    else:                                                     # 앞 자리가 연산 기호가 아닐 경우, 숫자일 것이므로 합쳐서 추가 ex) '1','2','3'이 아닌 '123'으로
        comp[-1] = comp[-1]+chr

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------사칙연산 수행 함수--------------------------------------------------------------------------------------------------------------------------------
#나눗셈과 뺄셈은 곱셈과 덧셈으로 바꿔준 후 곰셈 먼저 앞에서부터 계산


def arith(x):
    while '/' in x:
        div = x.index('/')
        divex = 1 / float(x[div+1])
        del x[div:div+2]
        x.insert(div,'*')
        x.insert(div+1, str(divex))
        
    while '-' in x:
        sub = x.index('-')
        minex = -float(x[sub+1])
        del x[sub:sub+2]
        x.insert(sub,'+')
        x.insert(sub+1, str(minex))
        
    while '*' in x:
        mul = x.index('*')
        mulre = float(x[mul-1]) * float(x[mul+1])
        del x[mul-1:mul+2]
        x.insert(mul-1, str(mulre))
        
    while '+' in x:
        add = x.index('+')
        addre = float(x[add-1]) + float(x[add+1])
        del x[add-1:add+2]
        x.insert(add-1, str(addre))
        
    return float(x[0])

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------괄호 계산----------------------------------------------------------------------------------------------------------------------------------------

parp = 0
parm = 0
def n_par(x):                                             # 첫 번째 ')' 가 나올 때, ')'보다 앞에 위치하면서 가장 가까운 '('의 위치를 함께 기록.
    global parp                                           # 즉, 가장 우선적으로 계산할 괄호의 위치 기록 
    global parm                                           
    lenx = len(x)
    for i in range(lenx):
        if x[i] == '(':
            parp = i
        
        elif x[i] == ')':
            parm = i
            break
    return parp, parm


def par(x):                                               # 가장 우선적으로 계산할 괄호를 계산하고 그 값을 해당 위치에 반환
    par = x[n_par(x)[0]+1:n_par(x)[1]]
    paa = arith(par)
    x.insert(n_par(x)[1]+1, int(paa))
    del x[n_par(x)[0]:n_par(x)[1]+1]
    return x

#----------------------------------------------------------------------------------------------------------------------------------------------------------------------


#--------------------실제 계산 수행-------------------------------------------------------------------------------------------------------------------------------------

if '(' not in comp:                                       # 괄호가 없으면 사칙연산 수행
    print('정답:',arith(comp))

else:
    nop = comp.count('(')                                 # 괄호가 있으면 리스트 m 에 구성 요소를 담은 리스트 추가
    m.append(comp)                                        # 이후 괄호의 개수 만큼 괄호 계산 반복 수행, 수행 결과는 리스트 m에 추가
    while nop > 0:                                        
        m.append(par(m[-1]))                                
        nop += -1
        
    if nop == 0:                                          # 리스트m에 마지막으로 추가된(괄호가 다 벗겨진) 수식에 사칙연산 수행  
        print('정답:',arith(m[-1]))
    
#----------------------------------------------------------------------------------------------------------------------------------------------------------------------    

        

